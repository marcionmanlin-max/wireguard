#!/usr/bin/env python3
"""
IonMan DNS - dnsmasq Configuration Generator
Generates dnsmasq config from blocked domains, whitelist, and custom blacklist.
"""

import mysql.connector
import subprocess
import os
import sys

# Credentials: loaded from config/db.env (gitignored) or system env vars.
# Copy config/db.env.example → config/db.env and fill in your values.
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
from config_loader import load_env; load_env()

DB_CONFIG = {
    'host':     os.environ.get('IONMAN_DB_HOST', 'localhost'),
    'user':     os.environ.get('IONMAN_DB_USER', ''),
    'password': os.environ.get('IONMAN_DB_PASS', ''),
    'database': os.environ.get('IONMAN_DB_NAME', 'ionman_dns'),
}

DNSMASQ_MAIN_CONF = '/etc/dnsmasq.d/makodns.conf'
DNSMASQ_BLOCKLIST_CONF = '/etc/dnsmasq.d/makodns-blocklist.conf'
CATEGORIES_FILE = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'config', 'categories.json')

def get_setting(cursor, key, default=''):
    cursor.execute("SELECT setting_value FROM settings WHERE setting_key = %s", (key,))
    row = cursor.fetchone()
    return row['setting_value'] if row else default

def generate_config():
    db = mysql.connector.connect(**DB_CONFIG)
    cursor = db.cursor(dictionary=True)
    
    # Get settings
    blocking_enabled = get_setting(cursor, 'blocking_enabled', '1') == '1'
    blocking_mode = get_setting(cursor, 'blocking_mode', '0.0.0.0')
    upstream_dns = get_setting(cursor, 'upstream_dns', '8.8.8.8,8.8.4.4,1.1.1.1')
    dns_port = get_setting(cursor, 'dns_port', '53')
    cache_size = get_setting(cursor, 'cache_size', '1000')
    log_queries = get_setting(cursor, 'log_queries', '1') == '1'

    # Sync upstream_dns into resolver.json so IonMan Resolver uses these servers
    import json as _resolver_json
    resolver_config_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'config', 'resolver.json')
    try:
        resolver_cfg = {}
        if os.path.exists(resolver_config_path):
            with open(resolver_config_path) as _f:
                resolver_cfg = _resolver_json.load(_f)
        upstream_list = []
        for entry in upstream_dns.split(','):
            entry = entry.strip()
            if entry:
                upstream_list.append({'host': entry, 'port': 53, 'dot': False, 'name': entry})
        resolver_cfg['upstreams'] = upstream_list
        with open(resolver_config_path, 'w') as _f:
            _resolver_json.dump(resolver_cfg, _f, indent=2)
        print(f"Synced {len(upstream_list)} upstream(s) to resolver.json")
    except Exception as _e:
        print(f"Warning: Could not sync resolver.json: {_e}")

    # Generate main dnsmasq config
    # Port 5353: DNS proxy sits in front on port 53 for per-peer category blocking
    main_config = f"""# IonMan DNS - Auto-generated dnsmasq configuration
# Generated by dnsmasq_config.py - DO NOT EDIT MANUALLY

# Listen on loopback only (DNS proxy forwards to us)
listen-address=127.0.0.1
bind-interfaces

# DNS port (behind proxy on 5353)
port=5353

# Forward all non-blocked queries to IonMan Resolver (caching recursive resolver)
server=127.0.0.1#5300
"""
    
    main_config += f"""
# Cache settings
cache-size={cache_size}

# Don't read /etc/resolv.conf
no-resolv

# Don't read /etc/hosts
no-hosts

# Never forward plain names (without a dot or domain part)
domain-needed

# Never forward addresses in the non-routed address spaces
bogus-priv
"""
    
    if log_queries:
        main_config += """
# Log queries for IonMan DNS dashboard
log-queries
log-facility=/var/log/dnsmasq-makodns.log
"""
    
    main_config += """
# Include blocklist
conf-file=/etc/dnsmasq.d/makodns-blocklist.conf
"""
    
    # Write main config
    with open(DNSMASQ_MAIN_CONF, 'w') as f:
        f.write(main_config)
    print(f"Main config written to {DNSMASQ_MAIN_CONF}")
    
    # Generate blocklist config
    blocklist_config = "# IonMan DNS - Blocked domains\n"
    blocklist_config += f"# Auto-generated - DO NOT EDIT MANUALLY\n\n"
    
    if blocking_enabled:
        # Get whitelist
        cursor.execute("SELECT domain FROM whitelist")
        whitelist = set(row['domain'] for row in cursor.fetchall())
        print(f"Whitelist: {len(whitelist)} domains")
        
        # Get all blocked domains (from lists)
        cursor.execute("""
            SELECT DISTINCT bd.domain 
            FROM blocked_domains bd 
            JOIN blocklists bl ON bd.source_list_id = bl.id 
            WHERE bl.enabled = 1
        """)
        blocked = set()
        for row in cursor:
            domain = row['domain']
            if domain not in whitelist:
                blocked.add(domain)
        
        # Add custom blacklist (exclude category domains — handled by DNS proxy)
        category_domains = set()
        try:
            import json as _json
            if os.path.exists(CATEGORIES_FILE):
                with open(CATEGORIES_FILE) as cf:
                    cats = _json.load(cf)
                for cat_info in cats.values():
                    for d in cat_info.get('domains', []):
                        category_domains.add(d.lower())
                print(f"Category domains excluded: {len(category_domains)} (handled by DNS proxy)")
        except Exception as e:
            print(f"Warning: Could not load categories file: {e}")

        cursor.execute("SELECT domain, comment FROM custom_blacklist")
        for row in cursor:
            domain = row['domain']
            comment = row.get('comment', '') or ''
            # Skip category-managed domains (proxy handles per-peer)
            if domain.lower() in category_domains:
                continue
            if domain not in whitelist:
                blocked.add(domain)
        
        print(f"Total blocked domains: {len(blocked)} (after whitelist)")
        
        # Write blocked domains
        for domain in sorted(blocked):
            blocklist_config += f"address=/{domain}/{blocking_mode}\n"
    else:
        blocklist_config += "# Blocking is disabled\n"
        print("Blocking is disabled, empty blocklist generated")
    
    with open(DNSMASQ_BLOCKLIST_CONF, 'w') as f:
        f.write(blocklist_config)
    print(f"Blocklist config written to {DNSMASQ_BLOCKLIST_CONF}")
    
    db.close()
    
    # Restart dnsmasq
    try:
        subprocess.run(['systemctl', 'restart', 'dnsmasq'], check=True, capture_output=True)
        print("dnsmasq restarted successfully")
    except subprocess.CalledProcessError as e:
        print(f"Failed to restart dnsmasq: {e.stderr.decode()}")
        # Try to check config
        result = subprocess.run(['dnsmasq', '--test'], capture_output=True, text=True)
        print(f"Config test: {result.stdout} {result.stderr}")

if __name__ == '__main__':
    generate_config()
